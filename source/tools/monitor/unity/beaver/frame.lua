---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2022/12/21 2:39 PM
---

-- refer to https://blog.csdn.net/zx_emily/article/details/83024065

local unistd = require("posix.unistd")
local poll = require("posix.poll")

require("common.class")
local ChttpComm = require("httplib.httpComm")
local pystring = require("common.pystring")
local Cframe = class("frame", ChttpComm)

function Cframe:_init_()
    ChttpComm._init_(self)
    self._objs = {}
end

local function waitDataRest(fd, rest, tReq, tmo)
    tmo = tmo or 100  -- max wait 100ms, other wise
    local len = 0
    local tStream = {}
    while len < rest do
        local r = poll.rpoll(fd, tmo)
        if r == 0 then   -- wait time out
            return -1
        elseif r == 1 then
            local s = unistd.read(fd, 4096)
            table.insert(tStream, s)
            len = len + #s
        else        -- bad socket
            return -2
        end
    end
    tReq.data = tReq.data .. pystring:join("", tStream)
    return 0
end

local function waitHttpRest(fd, tReq)
    if tReq.header["content-length"] then
        local lenData = #tReq.data
        local lenInfo = tonumber(tReq.header["content-length"])

        local rest = lenInfo - lenData
        if rest > 10 * 1024 * 1024 then  -- limit max data len
            return -1
        end

        if waitDataRest(fd, rest, tReq) < 0 then
            return -2
        end
    end
    return 0
end

local function waitHttpHead(fd, tmo, maxLen)
    tmo = tmo or 100  -- max wait 100ms,
    maxLen = maxLen or 8192
    local use = 0
    local stream = ""
    while tmo > 0 do
        local r = poll.rpoll(fd, tmo)
        if r == 0 then
            return nil
        elseif r == 1 then
            local s = unistd.read(fd, maxLen - use)
            if type(s) == "string" then
                stream = stream .. s
                use = use + #stream
                if string.find(stream, "\r\n\r\n") then -- http head end with \r\n\r\n
                    return stream
                end
            end
            tmo = tmo - 1    -- time quota weill
        else   -- bad socket
            return nil
        end
    end
end

function Cframe:parse(fd, stream)
    local tStatus = pystring:split(stream, "\r\n", 1)
    if #tStatus < 2 then
        print("bad stream format.")
        return nil
    end

    local stat, heads = unpack(tStatus)
    local tStat = pystring:split(stat, " ")
    if #tStat < 3 then
        print("bad stat: "..stat)
        return nil
    end

    local method, path, vers = unpack(tStat)
    local tReq = self:parsePath(path)
    tReq.method = method
    tReq.vers = vers

    local tHead = pystring:split(heads, "\r\n\r\n", 1)
    if #tHead < 2 then
        print("bad head: " .. heads)
        return nil
    end
    local headers, data = unpack(tHead)
    local tHeader = pystring:split(headers, "\r\n")
    local header = {}
    for _, s in ipairs(tHeader) do
        local tKv = pystring:split(s, ":", 1)
        if #tKv < 2 then
            print("bad head kv value: " .. s)
            return nil
        end
        local k, v = unpack(tKv)
        k = string.lower(k)
        header[k] = pystring:lstrip(v)
    end
    tReq.header = header
    tReq.data = data
    if waitHttpRest(fd, tReq) < 0 then
        return nil
    end
    return tReq
end

function Cframe:echo404()
    local stat = self:packStat(404)
    local tHead = {
        ["Content-Type"] = "text/plain",
    }
    local body = "Oops! The page may have flown to Mars!!!\n"
    local headers = self:packHeaders(tHead, #body)
    local tHttp = {stat, headers, body}
    return pystring:join("\r\n", tHttp)
end

function Cframe:proc(fd)
    local stream = waitHttpHead(fd)
    if type(stream) ~= "string" then   -- read return stream or error code or nil
        return stream
    end

    local tReq = self:parse(fd, stream)
    if tReq then
        if self._objs[tReq.path] then
            local obj = self._objs[tReq.path]
            local res = obj:call(tReq)
            unistd.write(fd, res)
        else
            print("show all path.")
            for k, _ in pairs(self._objs) do
                print("path:",  k)
            end
            unistd.write(fd, self:echo404())
        end
    end
    collectgarbage("collect")
end

function Cframe:register(path, obj)
    assert(self._objs[path] == nil, "the " .. path .. " is already registered.")
    self._objs[path] = obj
end

return Cframe
