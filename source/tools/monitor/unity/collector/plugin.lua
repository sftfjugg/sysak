---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by liaozhaoyan.
--- DateTime: 2022/12/30 10:20 AM
---

require("class")

local Cplugin = class("plugin")

function Cplugin:_init_(proto, procffi, que, proto_q, fYaml)
    self._proto = proto
    fYaml = fYaml or "../collector/plugin.yaml"
    self._ffi = require("plugincffi")
    self._sig_cffi = procffi["cffi"]

    local res = self:loadYaml(fYaml)
    self._sig_cffi.plugin_init()
    self:setup(res.plugins, proto_q)
end

function Cplugin:_del_()
    self._sig_cffi.plugin_stop()
    for _, plugin in ipairs(self._plugins) do
        local cffi = plugin.cffi
        cffi.deinit()
    end
end

function Cplugin:loadYaml(fYaml)
    local lyaml = require("lyaml")
    local f = io.open(fYaml,"r")
    local s = f:read("*all")
    f:close()

    return lyaml.load(s)
end

function Cplugin:setup(plugins, proto_q)
    self._plugins = {}
    for _, plugin in ipairs(plugins) do
        local so = plugin.so
        if so then
            print(so)
            local cffi = self._ffi.load(so)
            local plugin = {
                so = plugin.so,
                cffi = cffi
            }
            cffi.init(proto_q);
            table.insert(self._plugins, plugin)
        end
    end
end

function Cplugin:load_label(unity_line, line)
    for i=0, 4 - 1 do
        local name = self._ffi.string(unity_line.indexs[i].name)
        local index = self._ffi.string(unity_line.indexs[i].index)

        if #name > 0 then
            table.insert(line.ls, {name = name, index = index})
        else
            return
        end
    end
end

function Cplugin:load_value(unity_line, line)
    for i=0, 32 - 1 do
        local name = self._ffi.string(unity_line.values[i].name)
        local value = unity_line.values[i].value

        if #name > 0 then
            table.insert(line.vs, {name = name, value = value})
        else
            return
        end
    end
end

function Cplugin:load_log(unity_line, line)
    local name = self._ffi.string(unity_line.logs[0].name)
    if #name > 0 then
        local log = self._ffi.string(unity_line.logs[0].log)
        self._ffi.C.free(unity_line.logs[0].log)   -- should free from strdup
        table.insert(line.log, {name = name, log = log})
    end
end

function Cplugin:_proc(unity_lines, lines)
    for i=0, unity_lines.num - 1 do
        local unity_line = unity_lines.line[i]
        local line = {line = self._ffi.string(unity_line.table),
                      ls = {},
                      vs = {},
                      log = {}}

        self:load_label(unity_line, line)
        self:load_value(unity_line, line)
        self:load_log(unity_line, line)
        table.insert(lines["lines"], line)
    end
end

function Cplugin:proc(t, lines)
    for _, plugin in ipairs(self._plugins) do
        local cffi = plugin.cffi
        local unity_lines = self._ffi.new("struct unity_lines")
        local res = cffi.call(t, unity_lines)
        if res == 0 then
            self:_proc(unity_lines, lines)
        end
        self._ffi.C.free(unity_lines.line)   -- should free memory.
    end
    return lines
end

return Cplugin
