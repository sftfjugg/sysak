#!/bin/sh
#****************************************************************#
# ScriptName: sysak.sh
# Author: weipu.zy@alibaba-inc.com
# Create Date: 2021-02-22 11:44
# Modify Author: $SHTERM_REAL_USER@alibaba-inc.com
# Modify Date: 2021-02-22 11:45
# Function: 
#***************************************************************#
WORK_PATH=`dirname $0`/.sysak_compoents
TOOLS_ROOT=$WORK_PATH/tools
TOOLS_PATH=$WORK_PATH/tools/`uname -r`
LIB_PATH=$WORK_PATH/lib/`uname -r`
SYSAK_MOD=$LIB_PATH/sysak.ko

function usage() {
	echo "Usage: $0 [opt] subcmd [cmdargs]"
	echo "       opt: -h, help information"
	echo "       subcmd:"
	echo "              list, show all components"
	echo "              help, help information for specify component"
}

function upgrade() {
	echo upgrade	
}

function get() {
	echo get $1
	return 1
}

declare -A sysak_list_map=()
parse_sysak_list() {
	if [ -f $TOOLS_ROOT/.sysak.rules ]; then
	while read line
	do
		local cmd=`echo $line | awk -F: '{print $1}'`
		if [ -n "$cmd" ]; then
			sysak_list_map[$cmd]=`echo $line | awk -F: '{print $2}'`
		fi
	done < $TOOLS_ROOT/.sysak.rules
	fi

	if [ -f $TOOLS_PATH/.sysak.rules ]; then
	while read line
	do
		local cmd=`echo $line | awk -F: '{print $1}'`
		if [ -n "$cmd" ]; then
			sysak_list_map[$cmd]=`echo $line | awk -F: '{print $2}'`
		fi
	done < $TOOLS_PATH/.sysak.rules
	fi
}

function list() {
	parse_sysak_list
	for key in ${!sysak_list_map[@]}; do
		echo $key
	done
}

sysakmod_depend()
{
	res=`lsmod | grep sysak`
	if [ -z "$res" ]; then
		insmod $LIB_PATH/sysak.ko
		if [ $? -ne 0 ]; then
			echo "insmod ko failed, command maybe not supported for this kernel."
			exit $?
		fi
	fi
}

component_depend_prev() {

	local rules=${sysak_list_map[$1]}
	local prev_rules_str=${rules%'};post'*}
	prev_rules_str=${prev_rules_str#*'prev{'}
	oldIFS=$IFS
	IFS=,
	local prev_rules=($prev_rules_str)
	IFS=$oldIFS
	for item in "${prev_rules[@]}"; do
		local rule=($item)
		key=${rule[0]}
		val=${rule[1]}
		if [[ $key == 'default' ]] || [[ "${*:2}" =~ "$key" ]]; then
			case $val in
				"modin")
					sysakmod_depend
					;;
				*)
					;;
			esac
		fi
	done
}

component_depend_post() {
	local rules=${sysak_list_map[$1]}
	local post_rules_str=${rules#*'post{'}
	post_rules_str=${post_rules_str%'}'*}
	oldIFS=$IFS
	IFS=,
	local post_rules=($post_rules_str)
	IFS=$oldIFS

	for item in "${post_rules[@]}"; do
		local rule=($item)
		key=${rule[0]}
		val=${rule[1]}
		if [[ $key == 'default' ]] || [[ "${*:2}" =~ "$key" ]]; then
			case $val in
				"modun")
					rmmod sysak
					;;
				*)
					;;
			esac
		fi
	done

}


#execute command,every command need such args:
# -h/--help: command usage
# -f/--file: output files, default stdout
#            output format jason
# -e/--enable
# -d/--disable
function execute() {
	parse_sysak_list
	exec_file=$TOOLS_ROOT/$1
	if [ ! -f $exec_file ];then
		exec_file=$TOOLS_PATH/$1
	fi

	if [ ! -f $exec_file ];then
		if [ $get_component ];then
			get $1
			if [ $? != 0 ]; then
				echo subcmd:$1 is not support
				exit -1
			fi
		else
			echo "no components, you should get first"
			exit -1
		fi
	fi

	chmod -R +x $exec_file
	component_depend_prev $*
	$exec_file ${*:2}
	component_depend_post $*
}

#upload result data
function upload() {
	echo upload
}

while getopts 'h:g' OPT; do
	case $OPT in
		"h")
			usage
			exit 0
			;;
		"g")
			get_component=true
			break
			;;
		*)
			usage
			exit -1
			break
		;;
	esac
done

if [ $get_component ]; then
	subcmd=$2;
	subargs=${*:3}
else
	subcmd=$1
	subargs=${*:2};
fi

if [ -z $subcmd ];then
	usage
	exit -1
fi

#echo subcmd=$subcmd
case $subcmd in
	"help")
		execute ${subargs[0]} -h
		;;
	"upgrade")
		upgrade
		;;
	"list")
		list
		;;
	"get")
		get $2
		;;
	"upload")
		upload
		;;
	*)
		execute $subcmd $subargs
		;;
esac
